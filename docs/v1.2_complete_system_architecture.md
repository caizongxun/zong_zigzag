# ZigZag反轉預測系統 v1.2 完整架構

## 系統願景

您的最終目標是清晰的：

```
系統輸出:
  ✓ BTC 15m: "推薦不開單"
  ✓ ETH 4h: "推薦在3000開多單, SL: 2950, TP: 3200"
  ✓ SOL 1h: "推薦在120.5開空單, SL: 122, TP: 115"
```

這不是簡單的買賣信號，而是一個**完整的交易建議系統**:
- **何時進場** (價格位置)
- **如何進場** (多/空)
- **何處停損**
- **何處獲利**
- **信心度** (推薦/謹慎/不推薦)

---

## 核心系統架構

### 層級1: 多時間框架價格預測 (Multi-Timeframe Price Prediction)

使用多時間框架預測:

```
輸入:
  - 15分鐘OHLCV
  - 1小時OHLCV
  - 4小時OHLCV
  - 1天OHLCV
  
模型:
  CNN提取局部價格模式 (15m高頻信息)
  LSTM捕捉時間序列 (1h、4h、1d趨勢)
  Transformer整合多時間框架
  
輸出:
  - 未來5根K棒的價格區間 (15分鐘)
  - 未來4根K棒的價格區間 (1小時)
  - 未來8根K棒的價格區間 (4小時)
```

**具體實作:**
```python
class MultiTimeframePredictor:
    def __init__(self):
        self.tf_15m_model = build_cnn_lstm()    # 高頻
        self.tf_1h_model = build_lstm()         # 中頻
        self.tf_4h_model = build_transformer()  # 低頻
        self.fusion_model = build_attention_fusion()  # 融合層
    
    def predict_all_timeframes(self, price_data):
        """
        同時預測所有時間框架
        """
        pred_15m = self.tf_15m_model.predict(price_data['15m'])  # 短期方向
        pred_1h = self.tf_1h_model.predict(price_data['1h'])     # 中期趨勢
        pred_4h = self.tf_4h_model.predict(price_data['4h'])     # 長期趨勢
        
        # 融合不同時間框架的預測
        fused_prediction = self.fusion_model.predict([
            pred_15m, pred_1h, pred_4h
        ])
        
        return {
            'price_15m': pred_15m['next_5_candles'],
            'direction_15m': pred_15m['direction'],
            'price_1h': pred_1h['next_4_candles'],
            'direction_1h': pred_1h['direction'],
            'price_4h': pred_4h['next_8_candles'],
            'direction_4h': pred_4h['direction'],
            'consensus_direction': fused_prediction['consensus']
        }
```

---

### 層級2: 動態斐波那契和布林通道預測 (Dynamic Indicator Prediction)

關鍵創新：不是用固定的fib 0.618，而是**預測斐波那契和布林通道本身**

```
輸入:
  - 最近的swing高點 (HH)
  - 最近的swing低點 (LL)
  - 當前價格
  - 波動率(ATR)
  
輸出層級:
  
  1. 斐波那契動態級別:
     - 計算最近swing的fib retracement
     - 預測未來會測試的fib級別
     - 預測每個級別的"強度"(被測試次數)
  
  2. 布林通道動態級別:
     - 計算動態布林通道 (20期SMA, 2個std)
     - 預測上軌/下軌位置
     - 預測通道將收縮還是擴張
     - 計算價格到上/下軌的距離
```

**具體實作:**
```python
class DynamicIndicatorPredictor:
    def __init__(self):
        self.fib_predictor = build_lstm()      # LSTM預測fib級別
        self.bb_predictor = build_xgboost()    # XGBoost預測BB級別
        self.swing_detector = SwingDetector()  # 偵測swing
    
    def predict_dynamic_levels(self, ohlcv):
        """
        預測動態支撑阻力級別
        """
        # 1. 識別最近的swing
        swings = self.swing_detector.find_swings(ohlcv)  # HH, HL, LL, LH
        
        if not swings:
            return None
        
        latest_swing = swings[-1]
        
        # 2. 計算斐波那契級別
        fib_levels = self.calculate_fibonacci_levels(
            latest_swing['high'], 
            latest_swing['low']
        )
        # 輸出: {0.236, 0.382, 0.5, 0.618, 0.705, 0.786}
        
        # 3. 預測哪個fib級別會被測試
        fib_features = self.extract_fib_features(
            ohlcv, fib_levels, latest_swing
        )
        fib_prob = self.fib_predictor.predict(fib_features)
        # 輸出: {'0.618': 0.75, '0.786': 0.45, ...}
        
        # 4. 計算動態布林通道
        sma_period = self.optimize_sma_period(ohlcv)  # 自適應
        bb_levels = self.calculate_bollinger_bands(
            ohlcv, sma_period
        )
        
        # 5. 預測BB級別的移動
        bb_features = self.extract_bb_features(ohlcv, bb_levels)
        bb_future = self.bb_predictor.predict(bb_features)
        # 輸出: {'next_upper': 65000, 'next_lower': 63000}
        
        return {
            'fibonacci_levels': fib_levels,
            'fibonacci_probability': fib_prob,
            'bollinger_bands': bb_levels,
            'bollinger_future': bb_future
        }
    
    def calculate_fibonacci_levels(self, high, low):
        """
        計算fib級別 (不是固定的，而是基於最近的swing)
        """
        diff = high - low
        levels = {
            '0.236': high - (diff * 0.236),
            '0.382': high - (diff * 0.382),
            '0.5': high - (diff * 0.5),
            '0.618': high - (diff * 0.618),
            '0.705': high - (diff * 0.705),
            '0.786': high - (diff * 0.786),
        }
        return levels
```

---

### 層級3: ZigZag模式整合 (ZigZag Pattern Integration)

與您之前的v1.0整合ZigZag

```
結合:
  - ZigZag識別的HH/HL/LL/LH點
  - 預測的價格方向
  - 預測的fib/BB級別
  
輸出:
  - "我們正在哪個ZigZag階段?"
  - "下一個swing會在哪裡?"
  - "反轉的概率有多高?"
```

**具體實作:**
```python
class ZigZagIntegration:
    def __init__(self, zigzag_v1_model):
        self.zigzag_model = zigzag_v1_model  # 您的v1.0模型
        self.pattern_analyzer = PatternAnalyzer()
    
    def integrate_zigzag_prediction(self, 
                                     price_predictions,
                                     indicator_predictions):
        """
        將ZigZag、價格預測、指標預測整合在一起
        """
        # 1. 執行ZigZag模式識別 (v1.0)
        zigzag_points = self.zigzag_model.predict(ohlcv)
        current_phase = zigzag_points['current_phase']  # HH/HL/LL/LH
        
        # 2. 分析當前ZigZag階段的特徵
        if current_phase == 'HL':  # 下跌中
            expected_next = 'LL'  # 預期下一個低點
            direction_bias = 'down'
        elif current_phase == 'LL':  # 低點形成
            expected_next = 'LH'  # 預期反轉上升
            direction_bias = 'up'
        elif current_phase == 'LH':  # 上升中
            expected_next = 'HH'  # 預期上升繼續
            direction_bias = 'up'
        elif current_phase == 'HH':  # 高點形成
            expected_next = 'HL'  # 預期反轉下跌
            direction_bias = 'down'
        
        # 3. 比較ZigZag預期 vs 模型預測
        model_direction = price_predictions['consensus_direction']
        
        if model_direction == direction_bias:
            confidence = 0.85  # 高信心
        elif model_direction == 'neutral':
            confidence = 0.50  # 低信心
        else:
            confidence = 0.15  # 衝突信號
        
        return {
            'current_zigzag_phase': current_phase,
            'expected_next_phase': expected_next,
            'model_direction': model_direction,
            'consensus_confidence': confidence
        }
```

---

### 層級4: 進場點位預測 (Entry Point Prediction)

這是最關鍵的層級 - 生成具體的進場建議

```
輸入:
  - 預測的價格區間
  - 預測的fib級別和概率
  - 預測的BB級別
  - ZigZag整合結果
  - 市場波動率
  - 成交量
  
輸出:
  - 最優進場價格
  - 進場類型 (多/空)
  - 停損位置
  - 利潤目標 (TP1, TP2, TP3)
  - 推薦等級 (強烈推薦/推薦/謹慎/不推薦)
```

**具體實作:**
```python
class EntryPointGenerator:
    def __init__(self):
        self.entry_model = build_xgboost()      # 預測最優進場
        self.sl_model = build_regression()      # 預測停損
        self.tp_model = build_regression()      # 預測利潤目標
    
    def generate_trade_signal(self,
                              price_pred,
                              indicator_pred,
                              zigzag_result):
        """
        生成完整的交易信號
        """
        
        # 1. 確定交易方向
        direction = self.determine_direction(
            price_pred['consensus_direction'],
            indicator_pred['fibonacci_probability'],
            zigzag_result['consensus_confidence']
        )
        
        if direction is None:
            return {'recommendation': '推薦不開單'}
        
        # 2. 計算最優進場點
        entry_features = self.extract_entry_features(
            price_pred, indicator_pred, zigzag_result
        )
        
        optimal_entry = self.entry_model.predict(entry_features)
        
        # 3. 計算停損
        sl_features = self.extract_sl_features(
            price_pred, indicator_pred, direction
        )
        stop_loss = self.sl_model.predict(sl_features)
        
        # 4. 計算利潤目標
        tp_features = self.extract_tp_features(
            price_pred, indicator_pred, direction
        )
        take_profits = self.tp_model.predict(tp_features)  # 返回 [TP1, TP2, TP3]
        
        # 5. 計算信心度
        confidence = self.calculate_confidence(
            price_pred,
            indicator_pred,
            zigzag_result
        )
        
        # 6. 生成推薦文字
        recommendation = self.generate_recommendation(
            direction,
            optimal_entry,
            stop_loss,
            take_profits,
            confidence
        )
        
        return {
            'recommendation': recommendation,
            'direction': direction,
            'entry_price': optimal_entry,
            'stop_loss': stop_loss,
            'take_profits': take_profits,
            'confidence': confidence,
            'timeframe': 'preferred_timeframe'  # 15m/1h/4h
        }
    
    def determine_direction(self, price_dir, fib_prob, zz_conf):
        """
        多層驗證確定交易方向
        """
        # 權重組合
        score_long = 0
        score_short = 0
        
        # 價格預測貢獻 (50%權重)
        if price_dir == 'up':
            score_long += 0.5 * 1.0
            score_short += 0.5 * 0.0
        elif price_dir == 'down':
            score_long += 0.5 * 0.0
            score_short += 0.5 * 1.0
        else:
            score_long += 0.5 * 0.5
            score_short += 0.5 * 0.5
        
        # Fib概率貢獻 (30%權重)
        # 假設上升時fib 0.618被測試概率最高
        top_fib = max(fib_prob.items(), key=lambda x: x[1])
        if top_fib[0] in ['0.236', '0.382', '0.5']:
            score_long += 0.3  # 上升反轉
            score_short += 0.0
        else:
            score_long += 0.0
            score_short += 0.3  # 下跌反轉
        
        # ZigZag信心貢獻 (20%權重)
        score_long += 0.2 * zz_conf if zz_conf > 0 else 0
        score_short += 0.2 * zz_conf if zz_conf < 0 else 0
        
        # 決定
        if score_long > 0.55:
            return 'long'
        elif score_short > 0.55:
            return 'short'
        else:
            return None  # 信號不清晰
    
    def generate_recommendation(self, direction, entry, sl, tp, confidence):
        """
        生成用戶友好的推薦文字
        """
        if direction is None:
            return "推薦不開單"
        
        direction_text = "多單" if direction == 'long' else "空單"
        
        if confidence > 0.75:
            rec_level = "強烈推薦"
        elif confidence > 0.60:
            rec_level = "推薦"
        elif confidence > 0.45:
            rec_level = "謹慎推薦"
        else:
            return "推薦不開單"
        
        return f"{rec_level}在{entry}開{direction_text}, SL: {sl}, TP: {','.join(map(str, tp))}"
```

---

### 層級5: 多資產批量信號生成 (Multi-Asset Signal Generation)

您想要的最終輸出格式：

```python
class MultiAssetSignalGenerator:
    def __init__(self):
        self.price_predictor = MultiTimeframePredictor()
        self.indicator_predictor = DynamicIndicatorPredictor()
        self.zigzag = ZigZagIntegration(zigzag_v1_model)
        self.entry_generator = EntryPointGenerator()
    
    def generate_all_signals(self, assets_list, timeframes=['15m', '1h', '4h']):
        """
        為所有資產生成交易信號
        
        輸出範例:
          BTC 15m: 推薦不開單
          ETH 4h: 推薦在3000開多單, SL: 2950, TP1: 3200, TP2: 3400
          SOL 1h: 強烈推薦在120.5開空單, SL: 122, TP: 115
        """
        signals = {}
        
        for asset in assets_list:  # BTC, ETH, SOL, ...
            asset_signals = {}
            
            for tf in timeframes:  # 15m, 1h, 4h
                # 獲取該資產的OHLCV數據
                ohlcv = self.fetch_ohlcv(asset, tf)
                
                # 預測價格
                price_pred = self.price_predictor.predict_all_timeframes(ohlcv)
                
                # 預測指標
                indicator_pred = self.indicator_predictor.predict_dynamic_levels(ohlcv)
                
                # ZigZag整合
                zz_result = self.zigzag.integrate_zigzag_prediction(
                    price_pred, indicator_pred
                )
                
                # 生成進場信號
                signal = self.entry_generator.generate_trade_signal(
                    price_pred, indicator_pred, zz_result
                )
                
                asset_signals[tf] = signal
            
            # 選擇最佳時間框架
            best_signal = self.select_best_timeframe(asset_signals)
            signals[f"{asset} {best_signal['timeframe']}"] = best_signal
        
        return signals
    
    def select_best_timeframe(self, tf_signals):
        """
        從3個時間框架中選擇最佳信號
        (選擇信心度最高的)
        """
        best = None
        best_confidence = -1
        
        for tf, signal in tf_signals.items():
            if signal.get('confidence', 0) > best_confidence:
                best_confidence = signal.get('confidence', 0)
                best = signal.copy()
                best['timeframe'] = tf
        
        return best
    
    def print_signals(self, signals):
        """
        打印用戶友好的信號輸出
        """
        print("\n" + "="*60)
        print("交易信號生成時間: " + str(datetime.now()))
        print("="*60)
        
        for asset, signal in signals.items():
            print(f"\n{asset}:")
            print(f"  推薦: {signal['recommendation']}")
            if signal.get('confidence'):
                print(f"  信心度: {signal['confidence']*100:.1f}%")
        
        print("\n" + "="*60)
```

---

## 訓練數據標籤策略

### 標籤1: 進場成功性 (Binary)
```python
def label_entry_success(ohlcv, entry_idx, entry_price, direction, lookahead=20):
    """
    進場後20根K棒內是否獲利?
    """
    future_prices = ohlcv.iloc[entry_idx:entry_idx+lookahead]['close']
    
    if direction == 'long':
        max_profit = (future_prices.max() - entry_price) / entry_price
        max_loss = (future_prices.min() - entry_price) / entry_price
    else:  # short
        max_profit = (entry_price - future_prices.min()) / entry_price
        max_loss = (entry_price - future_prices.max()) / entry_price
    
    # 利潤需要至少勝風險1.5倍以上
    if max_profit > abs(max_loss) * 1.5:
        return 1  # 好進場
    else:
        return 0  # 壞進場
```

### 標籤2: 進場品質分數 (Continuous 0-100)
```python
def label_entry_quality(ohlcv, entry_idx, entry_price, direction, lookahead=20):
    """
    進場品質分數 (0-100)
    考慮: 獲利幅度、最大回撤、風險報酬比
    """
    future_prices = ohlcv.iloc[entry_idx:entry_idx+lookahead]['close']
    
    if direction == 'long':
        returns = (future_prices - entry_price) / entry_price
    else:
        returns = (entry_price - future_prices) / entry_price
    
    # 分數計算
    score = 0
    
    # 最大獲利 (40分)
    max_return = returns.max()
    score += min(40, max_return * 100)
    
    # 最小回撤 (30分)
    max_drawdown = -returns.min()
    score += max(0, 30 - max_drawdown * 100)
    
    # 風險報酬比 (20分)
    if max_drawdown > 0:
        rrr = max_return / max_drawdown
        if rrr > 3:
            score += 20
        elif rrr > 2:
            score += 15
        elif rrr > 1:
            score += 10
    
    # 勝率 (10分)
    win_rate = (returns > 0).sum() / len(returns)
    score += win_rate * 10
    
    return int(score)
```

### 標籤3: 最優進場點 (Regression)
```python
def label_optimal_entry(ohlcv, entry_idx, direction, lookahead=20):
    """
    在該進場區域內，哪個價格是最優進場點?
    """
    future_prices = ohlcv.iloc[entry_idx:entry_idx+lookahead]['close']
    
    if direction == 'long':
        # 多單: 最低點是最優進場
        optimal_price = future_prices.min()
    else:  # short
        # 空單: 最高點是最優進場
        optimal_price = future_prices.max()
    
    return optimal_price
```

---

## 實施計畫 (GitHub)

### 目錄結構
```
develop分支:
03_complete_signal_system/
├── price_predictor.py          # 多時間框架價格預測
├── indicator_predictor.py       # 動態fib/BB預測
├── zigzag_integration.py        # ZigZag整合
├── entry_point_generator.py     # 進場點位生成
├── multi_asset_signals.py       # 多資產批量信號
├── label_generator.py           # 訓練標籤生成
├── train_all_models.py          # 訓練所有子模型
└── signal_output_formatter.py   # 輸出格式化
```

### 核心流程圖
```
原始數據 (OHLCV, 多時間框架)
    ↓
[價格預測層] → 預測未來5/4/8根K棒的價格
    ↓
[指標預測層] → 預測動態fib級別、BB級別
    ↓
[ZigZag整合] → 結合HH/HL/LL/LH階段
    ↓
[進場點位生成] → 確定方向、價格、SL、TP
    ↓
[信號輸出] → "推薦在3000開多單, SL: 2950, TP: 3200"
```

---

## 預期結果

### v1.0 vs v1.2

**v1.0輸出:**
```
BTC: HH (看多)
ETH: HL (看空)
SOL: LL (反轉信號)
```

**v1.2輸出:**
```
BTC 15m: 推薦不開單 (信心度 35%)

ETH 4h: 推薦在3000開多單
  進場: 3000
  停損: 2950 (0.5% SL)
  利潤1: 3200 (6.7% TP)
  利潤2: 3400 (13.3% TP)
  信心度: 78%

SOL 1h: 強烈推薦在120.5開空單
  進場: 120.5
  停損: 122.5 (1.7% SL)
  利潤1: 117 (2.9% TP)
  利潤2: 114 (5.4% TP)
  信心度: 85%
```

---

## 下一步

1. **決定第一個實施模塊** (建議: 價格預測層)
2. **收集訓練數據** (至少6個月的每分鐘K線)
3. **生成訓練標籤** (使用上述標籤策略)
4. **訓練子模型** (分別訓練各層)
5. **融合和驗證** (多資產回測)
